// Copyright 2016 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.


use util::codec;

use super::{number, Result, Error, bytes};

const NIL_FLAG: u8 = 0;
const BYTES_FLAG: u8 = 1;
const COMPACT_BYTES_FLAG: u8 = 2;
const INT_FLAG: u8 = 3;
const UINT_FLAG: u8 = 4;
// TODO: support following flag
// const FLOAT_FLAG: u8 = 5;
// const DECIMAL_FLAG: u8 = 6;
// const DURATION_FLAG: u8 = 7;
const MAX_FLAG: u8 = 250;

#[derive(PartialEq, Debug)]
pub enum Datum {
    Null,
    I64(i64),
    U64(u64),
    F32(f32),
    F64(f64),
    Bytes(Vec<u8>),
    MinValue,
    MaxValue,
}

/// `decode_datum` decodes on a datum from a byte slice generated by tidb.
pub fn decode_datum(buf: &[u8]) -> Result<(Datum, usize)> {
    // TODO use read instead.
    try!(codec::check_bound(buf, 1));

    let datum;
    let mut readed = 1;
    match buf[0] {
        INT_FLAG => {
            let v = try!(number::decode_i64(&buf[1..]));
            datum = Datum::I64(v);
            readed += 8;
        }
        UINT_FLAG => {
            let v = try!(number::decode_u64(&buf[1..]));
            datum = Datum::U64(v);
            readed += 8;
        }
        BYTES_FLAG => {
            let (v, l) = try!(bytes::decode_bytes(&buf[1..]));
            datum = Datum::Bytes(v);
            readed += l;
        }
        COMPACT_BYTES_FLAG => {
            let (v, l) = try!(bytes::decode_compact_bytes(&buf[1..]));
            datum = Datum::Bytes(v);
            readed += l;
        }
        NIL_FLAG => {
            datum = Datum::Null;
        }
        _ => unimplemented!(),
    }
    Ok((datum, readed))
}

/// `decode` decodes all datum from a byte slice generated by tidb.
pub fn decode(buf: &[u8]) -> Result<(Vec<Datum>, usize)> {
    let mut res = vec![];
    let mut readed = 0;
    while readed < buf.len() {
        let (v, vn) = try!(decode_datum(&buf[readed..]));
        res.push(v);
        readed += vn;
    }
    Ok((res, readed))
}

/// Get the approximate needed buffer size of values.
///
/// This function ensures that encoded values must fit in the given buffer size.
pub fn approximate_size(values: &[Datum], comparable: bool) -> usize {
    values.iter()
          .map(|v| {
              match *v {
                  Datum::I64(_) | Datum::U64(_) => 9,
                  Datum::Bytes(ref bs) => {
                      if comparable {
                          bytes::max_encoded_bytes_size(bs.len()) + 1
                      } else {
                          bs.len() + number::MAX_VAR_I64_LEN + 1
                      }
                  }
                  Datum::Null | Datum::MinValue | Datum::MaxValue => 1,
                  _ => unimplemented!(),
              }
          })
          .sum()
}

fn encode_bytes(buf: &mut [u8], value: &[u8], comparable: bool) -> Result<usize> {
    try!(codec::check_bound(buf, 1 + value.len()));
    let len = if comparable {
        buf[0] = BYTES_FLAG;
        try!(bytes::encode_bytes_to_buf(&mut buf[1..], value))
    } else {
        buf[0] = COMPACT_BYTES_FLAG;
        try!(bytes::encode_compact_bytes(&mut buf[1..], value))
    };
    Ok(len + 1)
}

/// Encode values to buf slice.
pub fn encode(buf: &mut [u8], values: &[Datum], comparable: bool) -> Result<usize> {
    let mut idx = 0;
    let mut find_min = false;
    for v in values {
        if find_min {
            return Err(Error::InvalidDataType("MinValue should be the last datum.".to_owned()));
        }
        match *v {
            Datum::I64(i) => {
                buf[idx] = INT_FLAG;
                idx += 1;
                try!(number::encode_i64(&mut buf[idx..], i));
                idx += 8;
            }
            Datum::U64(u) => {
                buf[idx] = UINT_FLAG;
                idx += 1;
                try!(number::encode_u64(&mut buf[idx..], u));
                idx += 8;
            }
            Datum::Bytes(ref bs) => {
                idx += try!(encode_bytes(&mut buf[idx..], bs, comparable));
            }
            Datum::Null => {
                buf[idx] = NIL_FLAG;
                idx += 1;
            }
            Datum::MinValue => {
                buf[idx] = BYTES_FLAG; // for backward compatibility
                idx += 1;
                find_min = true;
            }
            Datum::MaxValue => {
                buf[idx] = MAX_FLAG;
                idx += 1;
            }
            _ => unimplemented!(),
        }
    }
    Ok(idx)
}

pub fn encode_key(buf: &mut [u8], values: &[Datum]) -> Result<usize> {
    encode(buf, values, true)
}

pub fn encode_value(buf: &mut [u8], values: &[Datum]) -> Result<usize> {
    encode(buf, values, false)
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_datum_codec() {
        let mut table = vec![
			vec![Datum::I64(1)],
			vec![Datum::U64(1), Datum::Bytes(b"123".to_vec()), Datum::I64(-1)],
			vec![Datum::Null],
		];

        for vs in table.drain(..) {
            let mut buf = vec![0; approximate_size(&vs, true)];
            let written = encode_key(&mut buf, &vs).unwrap();
            let (decoded, readed) = decode(&buf[0..written]).unwrap();
            assert_eq!(written, readed);
            assert_eq!(vs, decoded);

            buf = vec![0; approximate_size(&vs, false)];
            let written = encode_value(&mut buf, &vs).unwrap();
            let (decoded, readed) = decode(&buf[0..written]).unwrap();
            assert_eq!(written, readed);
            assert_eq!(vs, decoded);
        }
    }
}
