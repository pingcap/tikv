mod endpoint;
mod aggregate;


use kvproto::kvrpcpb::LockInfo;
use kvproto::errorpb;

use std::result;
use std::error;

use storage::{txn, engine, mvcc};

quick_error! {
    #[derive(Debug)]
    pub enum Error {
        Region(err: errorpb::Error) {
            description("region related failure")
            display("region {:?}", err)
        }
        Locked(l: LockInfo) {
            description("key is locked")
            display("locked {:?}", l)
        }
        Other(err: Box<error::Error + Send + Sync>) {
            from()
            cause(err.as_ref())
            description(err.description())
            display("unknown error {:?}", err)
        }
    }
}

pub type Result<T> = result::Result<T, Error>;

impl From<engine::Error> for Error {
    fn from(e: engine::Error) -> Error {
        match e {
            engine::Error::Request(e) => Error::Region(e),
            _ => Error::Other(box e),
        }
    }
}

impl From<txn::Error> for Error {
    fn from(e: txn::Error) -> Error {
        match e {
            txn::Error::Mvcc(mvcc::Error::KeyIsLocked { primary, ts, key }) => {
                let mut info = LockInfo::new();
                info.set_primary_lock(primary);
                info.set_lock_version(ts);
                info.set_key(key);
                Error::Locked(info)
            }
            _ => Error::Other(box e),
        }
    }
}

pub use self::endpoint::{Host as EndPointHost, RequestTask, SelectContext, SINGLE_GROUP,
                         REQ_TYPE_SELECT, REQ_TYPE_INDEX};
